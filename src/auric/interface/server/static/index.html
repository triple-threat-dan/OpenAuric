<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Arcane Library | OpenAuric</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>

<body>
    <div class="container">
        <!-- Header -->
        <header>
            <h1>OPEN<span class="highlight">AURIC</span> // THE ARCANE LIBRARY</h1>
            <div id="status-badge" class="badge">CONNECTING...</div>
        </header>

        <!-- Main Content -->
        <main>
            <!-- Chat Panel (The Void) - Takes up most space -->
            <section class="panel" id="chat-panel">
                <h2>üåå THE VOID (Communion)</h2>
                <div class="content scroll-box" id="chat-content">
                    <!-- Chat history injected here -->
                </div>
            </section>

            <!-- Sidebar (Grimoire + Logs) -->
            <div class="sidebar">
                <!-- Top Right: The Grimoire (Focus) -->
                <section class="panel" id="focus-panel">
                    <h2>üîÆ THE GRIMOIRE (Focus)</h2>
                    <div class="content" id="focus-content">
                        <div id="prime-directive"></div>
                        <ul id="plan-list"></ul>
                        <div id="working-memory"></div>
                    </div>
                </section>

                <!-- Bottom Right: The Stream (Logs) -->
                <section class="panel" id="log-panel">
                    <h2>üìú THE STREAM (Logs)</h2>
                    <div class="content scroll-box" id="log-content">
                        <!-- Logs will be injected here -->
                    </div>
                </section>
            </div>
        </main>

        <!-- Footer: Chat & Stats -->
        <footer>
            <div id="stats-bar">
                <span id="stat-model">Model: Unknown</span> |
                <span id="stat-mem">Mem: --</span>
            </div>
            <div class="input-area">
                <input type="text" id="chat-input" placeholder="Commune with the machine...">
                <button id="send-btn">SEND</button>
            </div>
        </footer>
    </div>

    <script>
        const API_URL = '/api';

        // Polling loop
        async function updateState() {
            try {
                const response = await fetch(`${API_URL}/status`);
                if (!response.ok) throw new Error('Network response was not ok');
                const data = await response.json();

                renderFocus(data.focus_state);
                renderChat(data.chat_history);
                renderLogs(data.logs);
                renderStats(data.stats);

                document.getElementById('status-badge').textContent = "ONLINE";
                document.getElementById('status-badge').classList.add('online');
            } catch (error) {
                document.getElementById('status-badge').textContent = "OFFLINE";
                document.getElementById('status-badge').classList.remove('online');
                console.error('Fetch error:', error);
            }
        }

        function renderFocus(focus) {
            const container = document.getElementById('focus-content');
            if (focus.error) {
                container.innerHTML = `<div class="error">${focus.error}</div>`;
                return;
            }

            // Prime Directive
            document.getElementById('prime-directive').innerHTML = `
                <h3>üéØ Prime Directive</h3>
                <p>${focus.prime_directive || "Assuming direct control..."}</p>
            `;

            // Plan
            const planList = document.getElementById('plan-list');
            planList.innerHTML = '<h3>üìã Plan of Action</h3>';
            if (focus.plan_steps) {
                focus.plan_steps.forEach(step => {
                    const li = document.createElement('li');
                    li.className = step.completed ? 'completed' : '';
                    li.innerHTML = `[${step.completed ? 'X' : ' '}] ${step.step}`;
                    planList.appendChild(li);
                });
            }

            // Memory
            document.getElementById('working-memory').innerHTML = `
                <h3>üß† Working Memory</h3>
                <pre>${focus.working_memory || ""}</pre>
            `;
        }

        function renderChat(history) {
            const container = document.getElementById('chat-content');
            if (!history) return;

            const html = history.map(msg => {
                const level = msg.level || "UNKNOWN";
                const text = msg.message || "";

                let className = "chat-entry";
                let icon = "";

                if (level === "USER") {
                    className += " user";
                    icon = "üë§";
                } else if (level === "AGENT") {
                    className += " agent";
                    icon = "üßô‚Äç‚ôÇÔ∏è";
                } else if (level === "THOUGHT") {
                    className += " thought";
                    icon = "üí≠";
                }

                // Parse Markdown for message content
                const content = marked.parse(text);

                return `<div class="${className}"><span class="icon">${icon}</span> <div class="text markdown-content">${content}</div></div>`;
            }).join('');

            // Only update if changed to avoid flicker (simple check length?)
            // For now, just simplistic replace
            if (container.innerHTML !== html) {
                container.innerHTML = html;
                container.scrollTop = container.scrollHeight;
            }
        }

        function renderLogs(logs) {
            const container = document.getElementById('log-content');
            container.innerHTML = logs.map(log => {
                // Formatting specific log types if they are structured strings, or just dumping
                if (typeof log === 'string' && log.includes('[ERROR]')) {
                    return `<div class="log-entry error">${log}</div>`;
                }
                return `<div class="log-entry">${log}</div>`;
            }).join('');
            // Auto scroll to bottom
            container.scrollTop = container.scrollHeight;
        }

        function renderStats(stats) {
            document.getElementById('stat-model').textContent = `Model: ${stats.active_model}`;
            document.getElementById('stat-mem').textContent = `Status: ${stats.status}`;
        }

        // Chat
        async function splitMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();
            if (!message) return;

            try {
                await fetch(`${API_URL}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message })
                });
                input.value = '';
            } catch (e) {
                alert("Failed to send message");
            }
        }

        document.getElementById('send-btn').addEventListener('click', splitMessage);
        document.getElementById('chat-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') splitMessage();
        });

        // Loop
        setInterval(updateState, 1000);
        updateState(); // Initial call
    </script>
</body>

</html>