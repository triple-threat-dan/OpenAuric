<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Arcane Library | OpenAuric</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>

<body>
    <div class="container">
        <!-- Header -->
        <header>
            <div class="logo-area">
                <img src="ALISS_AURIC.png" alt="ALISS Logo" class="logo-img">
                <h1>OPEN<span class="highlight">AURIC</span></h1>
            </div>
            <div id="status-badge" class="badge">CONNECTING...</div>
        </header>

        <!-- Main Content -->
        <main>
            <!-- Left Sidebar (Sessions) -->
            <section class="panel" id="session-panel">
                <div class="panel-header">
                    <h2>üìö SESSIONS</h2>
                    <div class="session-controls">
                        <button id="close-all-btn" onclick="closeAllSessions()"
                            title="Close All Active Sessions (Nuclear)"
                            style="background: #e74c3c; margin-right: 5px;">‚ò¢Ô∏è</button>
                        <button id="new-session-btn" onclick="startNewSession()" title="New Session">+</button>
                    </div>
                </div>
                <div class="content scroll-box" id="session-list">
                    <div class="session-item active" id="session-live" onclick="switchSession(null)">
                        <div class="session-id">üî¥ LIVE CHAT</div>
                        <div class="session-meta">Monitoring...</div>
                    </div>
                </div>
            </section>

            <!-- Chat Panel -->
            <section class="panel" id="chat-panel">
                <h2>üåå TERMINAL (Chat)</h2>
                <div class="content scroll-box" id="chat-content">
                    <!-- Chat history -->
                </div>
            </section>

            <!-- Sidebar (Context + Logs) -->
            <div class="sidebar">
                <!-- Top Right: Focus -->
                <section class="panel" id="focus-panel">
                    <h2>üîÆ SYSTEM CONTEXT</h2>
                    <div class="content" id="focus-content">
                        <div id="prime-directive"></div>
                        <ul id="plan-list"></ul>
                        <div id="working-memory"></div>
                    </div>
                </section>

                <!-- Bottom Right: Logs -->
                <!-- Bottom Right: Config / Navigation -->
                <section class="panel" id="config-panel">
                    <h2>‚öôÔ∏è SYSTEM CONTROL</h2>
                    <div class="content config-buttons">
                        <button class="nav-btn" onclick="alert('Settings not implemented yet.')">
                            <span class="icon">üõ†Ô∏è</span> Settings
                        </button>
                        <a href="system_logs.html" class="nav-btn">
                            <span class="icon">üìú</span> System Logs
                        </a>
                        <a href="llm_logs.html" class="nav-btn">
                            <span class="icon">üß†</span> LLM Logs
                        </a>
                    </div>
                </section>
            </div>
        </main>

        <!-- Footer: Chat & Stats -->
        <footer>
            <div id="stats-bar">
                <span id="stat-model">Model: Unknown</span> |
                <span id="stat-mem">Mem: --</span>
            </div>
            <div class="input-area">
                <input type="text" id="chat-input" placeholder="Commune with the machine...">
                <button id="send-btn">SEND</button>
            </div>
        </footer>
    </div>

    <!-- Login Modal -->
    <div id="login-modal" class="modal">
        <div class="modal-content">
            <h2>üîê Authentication Required</h2>
            <p>Please enter the Web UI Token from your console.</p>
            <p class="hint">Run <code>auric token</code> to retrieve it.</p>
            <input type="password" id="token-input" placeholder="Paste Token Here..." autocomplete="off">
            <button id="login-btn">Unlock Access</button>
            <p id="login-error" class="error-text"></p>
        </div>
    </div>

    </div>

    <script>
        const API_URL = '/api';
        let activeSessionId = null; // null = Live, string = UUID
        let lastSessionListJSON = "";
        let authToken = localStorage.getItem('auric_token');

        // Auth Logic
        const loginModal = document.getElementById('login-modal');
        const tokenInput = document.getElementById('token-input');
        const loginBtn = document.getElementById('login-btn');
        const loginError = document.getElementById('login-error');

        function showLogin() {
            loginModal.style.display = 'flex';
        }

        function hideLogin() {
            loginModal.style.display = 'none';
        }

        async function attemptLogin() {
            const token = tokenInput.value.trim();
            if (!token) return;

            // Verify token by hitting status endpoint
            try {
                const response = await fetch(`${API_URL}/status`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                if (response.ok) {
                    authToken = token;
                    localStorage.setItem('auric_token', token);
                    hideLogin();
                    updateState(); // Start loop
                } else {
                    loginError.textContent = "Invalid Token";
                }
            } catch (e) {
                loginError.textContent = "Connection Error";
            }
        }

        loginBtn.addEventListener('click', attemptLogin);
        tokenInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') attemptLogin();
        });

        // Wrapper for Fetch with Auth
        async function fetchAuth(url, options = {}) {
            if (!authToken) {
                showLogin();
                throw new Error("No Token");
            }

            const headers = options.headers || {};
            headers['Authorization'] = `Bearer ${authToken}`;
            options.headers = headers;

            const response = await fetch(url, options);

            if (response.status === 401) {
                // Token invalid/expired
                localStorage.removeItem('auric_token');
                authToken = null;
                showLogin();
                throw new Error("Unauthorized");
            }

            return response;
        }

        // Polling loop
        async function updateState() {
            if (!authToken) {
                showLogin();
                return;
            }

            try {
                const response = await fetchAuth(`${API_URL}/status`);
                if (!response.ok) throw new Error('Network response was not ok');
                const data = await response.json();

                renderFocus(data.focus_state);

                // Only render live chat if we are in "Live" mode
                if (activeSessionId === null) {
                    renderChat(data.chat_history);
                }

                renderLogs(data.logs);
                renderStats(data.stats);

                // Fetch sessions periodically
                fetchSessions();

                document.getElementById('status-badge').textContent = "ONLINE";
                document.getElementById('status-badge').classList.add('online');
            } catch (error) {
                // If 401, fetchAuth handled it. Otherwise:
                if (error.message !== "Unauthorized" && error.message !== "No Token") {
                    document.getElementById('status-badge').textContent = "OFFLINE";
                    document.getElementById('status-badge').classList.remove('online');
                    console.error('Fetch error:', error);
                }
            }
        }

        // ... Render Functions Omitted (Unchanged) ...

        // ... (We need to keep the render functions) ...
        // I will use multi_replace to target specific blocks or replace the whole script section if simpler.
        // Given complexity, let's just replace the top part of script and update fetch calls in other functions via logic below.

        // Actually, replace_file_content replaces a block. I can replace the start of script and updateState
        // and then I need to update other fetch calls to use fetchAuth.

        // Let's do this sequentially or use multi_replace.
        // multi_replace is better here.


        function renderFocus(focus) {
            const container = document.getElementById('focus-content');
            if (focus.error) {
                container.innerHTML = `<div class="error">${focus.error}</div>`;
                return;
            }

            // Prime Directive
            document.getElementById('prime-directive').innerHTML = `
                <h3>üéØ Prime Directive</h3>
                <p>${focus.prime_directive || "Assuming direct control..."}</p>
            `;

            // Plan
            const planList = document.getElementById('plan-list');
            planList.innerHTML = '<h3>üìã Plan of Action</h3>';
            if (focus.plan_steps) {
                focus.plan_steps.forEach(step => {
                    const li = document.createElement('li');
                    li.className = step.completed ? 'completed' : '';
                    li.innerHTML = `[${step.completed ? 'X' : ' '}] ${step.step}`;
                    planList.appendChild(li);
                });
            }

            // Memory
            document.getElementById('working-memory').innerHTML = `
                <h3>üß† Working Memory</h3>
                <pre>${focus.working_memory || ""}</pre>
            `;
        }

        let lastChatHistoryJSON = "";

        function renderChat(history) {
            const container = document.getElementById('chat-content');
            if (!history) return;

            // 1. Check if user is near bottom BEFORE updating
            const threshold = 50; // pixels
            const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < threshold;
            const isFirstLoad = container.innerHTML.trim() === "";

            const html = history.map(msg => {
                const level = msg.level || "UNKNOWN";
                const text = msg.message || "";

                let className = "chat-entry";
                let icon = "";

                if (level === "USER") {
                    className += " user";
                    icon = "üë§";
                } else if (level === "AGENT") {
                    className += " agent";
                    icon = "üßô‚Äç‚ôÇÔ∏è";
                }

                if (level === "THOUGHT") {
                    className += " thought";
                    // For thoughts, we ignore the text content and show a standardized "Thinking..."
                    // text = "Thinking..."; 
                    // But we want the icon + text wrapper.
                    // The icon is set below.
                    // Let's override the content generation logic.
                    icon = "üí≠";
                } else if (level === "UNKNOWN") {
                    // Try to infer from text or just default
                    if (text.startsWith("Thinking")) {
                        className += " thought";
                        icon = "üí≠";
                    }
                }

                // Parse Markdown for message content
                let content = (typeof marked !== 'undefined') ? marked.parse(text) : text;

                // Override content for thoughts
                if (level === "THOUGHT" || (level === "UNKNOWN" && text.startsWith("Thinking"))) {
                    content = `<span class="thinking-text">Thinking</span><span class="thinking-dots">...</span>`;
                }

                return `<div class="${className}"><span class="icon">${icon}</span> <div class="text markdown-content">${content}</div></div>`;
            }).join('');

            // Update if JSON changed
            const currentJSON = JSON.stringify(history);
            if (currentJSON !== lastChatHistoryJSON) {
                lastChatHistoryJSON = currentJSON;
                container.innerHTML = html;

                // 2. Only auto-scroll if user was already at bottom OR it's the first load
                if (isNearBottom || isFirstLoad) {
                    container.scrollTop = container.scrollHeight;
                }
            }
        }

        let lastLogJSON = "";

        /* Logs removed from main dash */
        function renderLogs(logs) {
            // No-op
        }

        function renderStats(stats) {
            document.getElementById('stat-model').textContent = `Model: ${stats.active_model}`;
            document.getElementById('stat-mem').textContent = `Status: ${stats.status}`;
        }

        // Chat
        async function splitMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();
            if (!message) return;

            // 0. Slash Command Check
            if (message.startsWith('/')) {
                const handled = await handleCommand(message);
                if (handled) {
                    input.value = '';
                    return;
                }
                // If not handled, we could either send it as text or warn.
                // For now, let's treat unknown commands as text or warn.
                // Let's send as text for flexibility unless it's a known command.
            }

            try {
                await fetchAuth(`${API_URL}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message })
                });
                input.value = '';
            } catch (e) {
                alert("Failed to send message");
            }
        }

        async function handleCommand(cmdString) {
            const args = cmdString.split(' ');
            const cmd = args[0].toLowerCase();

            if (cmd === '/new') {
                if (confirm("Start a new session?")) {
                    await startNewSession(true); // Helper to reuse logic
                }
                return true;
            }
            // Add more commands here

            return false;
        }

        document.getElementById('send-btn').addEventListener('click', splitMessage);
        document.getElementById('chat-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') splitMessage();
        });

        // Session Management
        async function fetchSessions() {
            try {
                const response = await fetchAuth(`${API_URL}/sessions`);
                if (!response.ok) return;
                const sessions = await response.json();

                const currentJSON = JSON.stringify(sessions);
                if (currentJSON === lastSessionListJSON) return;
                lastSessionListJSON = currentJSON;

                const container = document.getElementById('session-list');
                // Keep the "Live" item
                const liveItem = `<div class="session-item ${activeSessionId === null ? 'active' : ''}" id="session-live" onclick="switchSession(null)">
                        <div class="session-id">üî¥ LIVE CHAT</div>
                        <div class="session-meta">Monitoring...</div>
                    </div>`;

                const listHtml = sessions.map(sess => {
                    const isActive = activeSessionId === sess.session_id;
                    const date = sess.last_active ? new Date(sess.last_active).toLocaleString() : 'Unknown';
                    const displayName = sess.name || sess.session_id;
                    const statusBadge = sess.is_active ? '<span class="session-badge active-badge">üü¢ Active</span>' : '<span class="session-badge archived-badge">üì¶ Archived</span>';
                    return `
                    <div class="session-item ${isActive ? 'active' : ''}" onclick="switchSession('${sess.session_id}')">
                        <div class="session-content">
                            <div class="session-id">${displayName} ${statusBadge}</div>
                            <div class="session-meta">
                                <span>${date}</span>
                                <span>${sess.message_count} msgs</span>
                            </div>
                        </div>
                        <button class="close-session-btn" onclick="event.stopPropagation(); closeSession('${sess.session_id}')" title="Close Session">√ó</button>
                    </div>`;
                }).join('');

                container.innerHTML = liveItem + listHtml;
            } catch (e) {
                console.error("Failed to fetch sessions", e);
            }
        }

        async function switchSession(sessionId) {
            activeSessionId = sessionId;

            // Immediately update UI to show active state
            // Re-fetching sessions will re-render with correct active class
            fetchSessions();

            if (activeSessionId !== null) {
                // Load history for that session
                try {
                    const response = await fetchAuth(`${API_URL}/chat/${sessionId}`);
                    if (response.ok) {
                        const history = await response.json();
                        renderChat(history); // Render immediately
                    }
                } catch (e) {
                    console.error("Failed to load session history", e);
                }
            } else {
                // Clear current view temporarily or wait for next poll?
                // Next poll will pick it up in < 1s.
                document.getElementById('chat-content').innerHTML = ''; // Visual clear
            }
        }

        async function startNewSession(skipConfirm = false) {
            if (!skipConfirm && !confirm("Start a new session?")) return;

            try {
                await fetchAuth(`${API_URL}/sessions/new`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ context: "web" })
                });

                // Switch to live view
                activeSessionId = null;
                document.getElementById('chat-content').innerHTML = ''; // Clear chat immediately
                fetchSessions();
                updateState();
            } catch (e) {
                alert("Failed to start new session");
            }
        }

        async function closeSession(sessionId) {
            if (!confirm("Close this session? It will be archived.")) return;
            try {
                await fetchAuth(`${API_URL}/sessions/${sessionId}/close`, { method: 'POST' });
                if (activeSessionId === sessionId) {
                    activeSessionId = null;
                    document.getElementById('chat-content').innerHTML = '';
                }
                fetchSessions();
            } catch (e) {
                alert("Failed to close session: " + e.message);
            }
        }

        async function closeAllSessions() {
            if (!confirm("‚ò¢Ô∏è NUCLEAR OPTION ‚ò¢Ô∏è\n\nAre you sure you want to close ALL active sessions (Web, Discord, etc)?\nThis will rotate everything to fresh states.")) return;
            try {
                await fetchAuth(`${API_URL}/sessions/closeall`, { method: 'POST' });
                activeSessionId = null;
                document.getElementById('chat-content').innerHTML = '';
                fetchSessions();
                alert("All sessions closed.");
            } catch (e) {
                alert("Failed to close all sessions: " + e.message);
            }
        }

        // Loop
        setInterval(updateState, 1000);
        updateState(); // Initial call
        fetchSessions(); // Initial session load
    </script>
</body>

</html>